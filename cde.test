cde is a cd replacer
===================

    >>> import cde
    >>> assert cde.__doc__.startswith('cde.py knows where you are going')

More modules for testing
------------------------

    >>> import os
    >>> import sys

Command Line
------------

cde is intended to be used from the command line

On the command line we expect two arguments:
    The first is a possible directory
    The rest are prefixes of possible sub-directories

    >>> sys.argv = ['cde.py', 'start', 'here']
    >>> args = cde.parse_args()
    >>> assert args.dirname == 'start' and args.subdirnames == ['here']

No prefixes is fine too

    >>> sys.argv = ['cde.py', 'start']
    >>> args = cde.parse_args()
    >>> assert args.dirname == 'start' and args.subdirnames == []


Finding sub-directories
-----------------------

The parsed arguments are sent on to the cde.find_directory method
    Give it a directory to start on
    >>> assert cde.find_directory('/usr/lib', []) == '/usr/lib'

Or a file
    >>> assert cde.find_directory('/bin/ls', []) == '/bin'

Give it the name of a (possible) sub directory
    and it will combine them to one path
    >>> assert cde.find_directory('/usr/local', ['sbin']) == '/usr/local/sbin'

The sub-dir can be a prefix
    >>> assert cde.find_directory('/usr/local', ['sbi']) == '/usr/local/sbin'

It can handle many prefixes (albeit more slowly)
    >>> assert cde.find_directory('/', ['us', 'loc', 'sbi']) == '/usr/local/sbin'

In case of ambiguous sub-directories a number can choose one
    >>> assert cde.find_directory('/usr', ['li', '0']).startswith('/usr/li')

Fallbacks
---------

If directory is not found directly then try in PATH
    >>> assert cde.find_directory('grep', []) in { '/bin', '/usr/bin' }

If that fails, then try in home directory
    >>> assert cde.find_directory('.bashrc', []) == os.path.expanduser('~')

Running from bash
-----------------

If run from the command line the python process cannot change dir for calling process (bash)
    Hence the script just prints out the result
    bash can then capture that and do the actual cd

Hence the main method will print the found directory
    and then return 0 for success, 1 for fail
    >>> sys.argv = ['cde', '/usr', 'local', 'lib']
    >>> cde.main()
    /usr/local/lib
    0

Remembering history
-------------------

cde can also remember a list of paths

    >>> assert cde._path_to_history().endswith('cde/history')
    >>> class Args:
    ...     dirname = cde.__file__
    >>> cde.add(Args())
    >>> stored = False
    >>> for _rank, path, _time in cde.read_history():
    ...     if path == os.path.dirname(cde.__file__):
    ...          stored = True
    ...          break
    >>> assert stored
    >>> assert os.path.isfile(cde._path_to_history())


Finding in history
------------------

Assuming we have remembered some paths
    >>> history = [
    ...     '/usr/bin',
    ...     '/usr/local/bin',
    ...     '/usr/tin/local',
    ...     '/usr/bin/vocal',
    ...     '/usr/local/bib',
    ... ]

Then we should be able to search that history for a remembered item
    which should be found first is exact same as a history item
    >>> expected = sought = history[2]
    >>> assert expected == cde._find_in_paths(sought, [], history)

Or even if it is just the name of one
    >>> sought = os.path.basename(sought)
    >>> history_paths = [cde.paths.path(_) for _ in history]
    >>> assert expected == cde._find_in_paths(sought, [], history_paths)

Or even just the stem of the name
    >>> sought = sought[:3]
    >>> assert expected == cde._find_in_paths(sought, [], history_paths)


Cleanup
=======
    >>> sys.argv = []
